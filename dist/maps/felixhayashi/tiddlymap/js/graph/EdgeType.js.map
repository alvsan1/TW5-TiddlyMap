{"version":3,"sources":["felixhayashi/tiddlymap/js/graph/EdgeType.js"],"names":["env","EdgeType","id","data","getIdParts","marker","namespace","name","getId","path","edgeTypes","fieldMeta","arrows","style","invertedArrow","isArrowEnabled","toArrow","biArrow","Object","freeze","label","getWithoutPrefix","match","edgeTypeRegex","getInstance","direction","arrow","enabled","RegExp"],"mappings":"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","file":"../../../../../felixhayashi/tiddlymap/js/graph/EdgeType.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/EdgeType\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport MapElementType from '$:/plugins/felixhayashi/tiddlymap/js/MapElementType';\nimport utils          from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport * as env       from '$:/plugins/felixhayashi/tiddlymap/js/lib/environment';\n\n/*** Code **********************************************************/\n\n/**\n * This class is used to abstract edge types. It facilitates the parsing\n * of style information, the translation of type names into actual type data\n * or the persistance of edge type data.\n *\n * Note: EdgeType instances are immutable (frozen).\n */\nclass EdgeType extends MapElementType {\n\n  /**\n   * @param {EdgeTypeId} id\n   * @param {Object} [data] @see http://visjs.org/docs/network/edges.html\n   */\n  constructor(id, data) {\n\n    // we do not simply use the provided id but disassemble and\n    // reassemble it again to ensure the id is well formatted.\n    const { marker, namespace, name } = EdgeType.getIdParts(id);\n    id = EdgeType.getId(marker, namespace, name);\n\n    // call the parent constructor\n    super(id, env.path.edgeTypes, EdgeType.fieldMeta, data);\n\n    this.id = id;\n    this.marker = marker;\n    this.name = name;\n    this.namespace = namespace;\n\n    const arrows = (this.style || {}).arrows;\n\n    if (arrows) {\n\n      this.invertedArrow = isArrowEnabled(arrows, 'from');\n      this.toArrow = isArrowEnabled(arrows, 'to') || isArrowEnabled(arrows, 'middle');\n      // determine if bi arrows (either from+to or no arrows)\n      this.biArrow = (this.invertedArrow === this.toArrow);\n\n      if (this.biArrow) {\n        this.toArrow = true;\n        this.invertedArrow = true;\n      }\n\n    } else {\n\n      this.toArrow = true;\n    }\n\n    Object.freeze(this);\n\n  }\n\n  /**\n   * Returns an object holding the parts that make up the edge type id.\n   *\n   * @param {EdgeTypeId} id\n   * @return {{marker: (*|string), namespace: (*|string), name: (*|string)}}\n   */\n  static getIdParts(id = '') {\n\n    id = utils.getWithoutPrefix(id, `${env.path.edgeTypes}/`);\n    const match = id.match(edgeTypeRegex) || [];\n\n    return {\n      marker: match[1] || '',\n      namespace: (match[3] && match[2]) || '',\n      name: (match[3] || match[2]) || ''\n    };\n\n  };\n\n  /**\n   * Creates an {@link EdgeTypeId} from a set of parts that make up the id.\n   * If it is not possible to create the id from the parts, the default\n   * edge type 'tmap:unknown' is returned.\n   *\n   * @param {string} marker\n   * @param {string} namespace\n   * @param {string} name\n   * @return {EdgeTypeId}\n   */\n  static getId(marker = '', namespace = '', name) {\n\n    return name\n      ? marker + (namespace && `${namespace}:`) + name\n      : 'tmap:unknown';\n\n  }\n\n  getLabel() {\n\n    return this.label || this.name;\n\n  }\n}\n\n/**\n  * @see https://github.com/babel/babel/issues/4854\n  * @param {string} id - Either the edge type id (name)\n  *     or a tiddler reference denoting the type or an\n  *     `EdgeType` object (that is directly bounced back). If the\n  *     id can be translated into a tiddler object that resides in\n  *     the edge type path, then its data is retrieved automatically.\n */\nEdgeType.getInstance = id => id instanceof EdgeType ? id : new EdgeType(id);\n\nEdgeType.fieldMeta = {\n  ...MapElementType.fieldMeta,\n  'label': {},\n  'show-label': {},\n};\n\n/**\n *\n * @param {Object} arrows\n * @param {('from'|'to'|'middle')} direction\n * @return {boolean}\n */\nconst isArrowEnabled = (arrows, direction) => {\n\n  const arrow = arrows[direction];\n\n  if (arrow == null && direction === 'to') {\n    // if the arrow is not further specified and its direction is to\n    // we regard it as enabled.\n    return true;\n  }\n\n  return typeof arrow === 'object' ? arrow.enabled !== false : arrow === true;\n\n};\n\n/**\n * An edge-type id consists of the following parts of which the\n * first two are optional: `[marker][namespace:]name`\n *\n * The colon is not considered to be part of the namespace.\n */\nconst edgeTypeRegex = new RegExp('^(_?)([^:_][^:]*):?([^:]*)');\n\n/*** Exports *******************************************************/\n\nexport default EdgeType;\n"],"sourceRoot":"../../../../../../src/plugins"}