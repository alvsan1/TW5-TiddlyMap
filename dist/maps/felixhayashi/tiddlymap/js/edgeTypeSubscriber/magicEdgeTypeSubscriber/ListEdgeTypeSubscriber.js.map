{"version":3,"sources":["felixhayashi/tiddlymap/js/edgeTypeSubscriber/magicEdgeTypeSubscriber/ListEdgeTypeSubscriber.js"],"names":["ListEdgeTypeSubscriber","allEdgeTypes","options","priority","edgeType","namespace","tObj","fieldName","toWL","$tw","utils","parseStringArray","fields","edge","type","to","name","list","slice","toTRef","tracker","getTiddlerById","push","setField","stringifyList","index","indexOf","splice"],"mappings":";;;;;;;;;;;AAaA;;;;AACA;;;;;;;;;;+eAdA;AACA;;;;;;;;;;AAUA;;AAKA;;AAEA;;;;;;;;;;;;;;;;IAgBMA,sB;;;AAEJ;;;AAGA,kCAAYC,YAAZ,EAAwC;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAAA;;AAAA,2IAChCD,YADgC,aAChBE,UAAU,EADM,IACCD,OADD;AAEvC;;AAED;;;;;;;8BAGUE,Q,EAAU;;AAElB,aAAOA,SAASC,SAAT,KAAuB,SAA9B;AAED;;AAED;;;;;;2CAGuBC,I,EAAMC,S,EAAWC,I,EAAM;;AAE5C,aAAOC,IAAIC,KAAJ,CAAUC,gBAAV,CAA2BL,KAAKM,MAAL,CAAYL,SAAZ,CAA3B,CAAP;AAED;;AAED;;;;;;+BAGWD,I,EAAMO,I,EAAMC,I,EAAM;;AAE3B,UAAI,CAACD,KAAKE,EAAV,EAAc;AACZ;AACD;;AAED;AACA,UAAMC,OAAOF,KAAKE,IAAlB;;AAEA,UAAIC,OAAOR,IAAIC,KAAJ,CAAUC,gBAAV,CAA2BL,KAAKM,MAAL,CAAYI,IAAZ,CAA3B,CAAX;AACA;AACA;AACA;AACAC,aAAO,CAACA,QAAQ,EAAT,EAAaC,KAAb,EAAP;;AAEA;AACA,UAAMC,SAAS,KAAKC,OAAL,CAAaC,cAAb,CAA4BR,KAAKE,EAAjC,CAAf;;AAEAE,WAAKK,IAAL,CAAUH,MAAV;;AAEA;AACA,sBAAMI,QAAN,CAAejB,IAAf,EAAqBU,IAArB,EAA2BP,IAAIC,KAAJ,CAAUc,aAAV,CAAwBP,IAAxB,CAA3B;;AAEA,aAAOJ,IAAP;AAED;;;;;AAED;;;+BAGWP,I,EAAMO,I,EAAMC,I,EAAM;;AAE3B,UAAIG,OAAOR,IAAIC,KAAJ,CAAUC,gBAAV,CAA2BL,KAAKM,MAAL,CAAYE,KAAKE,IAAjB,CAA3B,CAAX;AACA;AACA;AACA;AACAC,aAAO,CAACA,QAAQ,EAAT,EAAaC,KAAb,EAAP;;AAEA;AACA,UAAMC,SAAS,KAAKC,OAAL,CAAaC,cAAb,CAA4BR,KAAKE,EAAjC,CAAf;;AAEA,UAAMU,QAAQR,KAAKS,OAAL,CAAaP,MAAb,CAAd;AACA,UAAIM,QAAQ,CAAC,CAAb,EAAgB;AACdR,aAAKU,MAAL,CAAYF,KAAZ,EAAmB,CAAnB;AACD;;AAED;AACA,sBAAMF,QAAN,CAAejB,IAAf,EAAqBQ,KAAKE,IAA1B,EAAgCP,IAAIC,KAAJ,CAAUc,aAAV,CAAwBP,IAAxB,CAAhC;;AAEA,aAAOJ,IAAP;AAED;;;;;;AAGH;;QAESb,sB,GAAAA,sB","file":"../../../../../../felixhayashi/tiddlymap/js/edgeTypeSubscriber/magicEdgeTypeSubscriber/ListEdgeTypeSubscriber.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/list\ntype: application/javascript\nmodule-type: tmap.edgetypehandler\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport utils from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport AbstractMagicEdgeTypeSubscriber from '$:/plugins/felixhayashi/tiddlymap/js/AbstractMagicEdgeTypeSubscriber';\n\n/*** Code **********************************************************/\n\n/**\n * The ListEdgeTypeSubstriber deals with connections that are stored inside\n * tiddler fields in a tiddler-list format.\n *\n * If an EdgeType with a 'tw-list\" namespace is inserted or deleted, the type's name\n * is interpreted as field name and the list of connections is stored or removed in a tiddler\n * field with of that name. Each outgoing connection to a tiddler is stored by\n * inserting the title the edge is pointing to into a list.\n *\n * Say you the user creates a connection between tiddler \"Dawna Dozal\" and\n * tiddler \"Toney Thacker\" and names the connection \"tw-list:friends\". Then a field\n * named \"friends\" will be created in tiddler \"Dawna Dozal\" and \"Toney Thacker\" will be\n * added to this field.\n *\n * @see http://tiddlymap.org/#tw-list\n */\nclass ListEdgeTypeSubscriber extends AbstractMagicEdgeTypeSubscriber {\n\n  /**\n   * @inheritDoc\n   */\n  constructor(allEdgeTypes, options = {}) {\n    super(allEdgeTypes, { priority: 10, ...options });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  canHandle(edgeType) {\n\n    return edgeType.namespace === 'tw-list';\n\n  }\n\n  /**\n   * @override\n   */\n  getReferencesFromField(tObj, fieldName, toWL) {\n\n    return $tw.utils.parseStringArray(tObj.fields[fieldName]);\n\n  }\n\n  /**\n   * Stores and maybe overrides an edge in this tiddler\n   */\n  insertEdge(tObj, edge, type) {\n\n    if (!edge.to) {\n      return;\n    }\n\n    // get the name without the private marker or the namespace\n    const name = type.name;\n\n    let list = $tw.utils.parseStringArray(tObj.fields[name]);\n    // we need to clone the array since tiddlywiki might directly\n    // returned the auto-parsed field value (as in case of tags, or list)\n    // and this array would be read only!\n    list = (list || []).slice();\n\n    // transform\n    const toTRef = this.tracker.getTiddlerById(edge.to);\n\n    list.push(toTRef);\n\n    // save\n    utils.setField(tObj, name, $tw.utils.stringifyList(list));\n\n    return edge;\n\n  };\n\n  /**\n   * Deletes an edge in this tiddler\n   */\n  deleteEdge(tObj, edge, type) {\n\n    let list = $tw.utils.parseStringArray(tObj.fields[type.name]);\n    // we need to clone the array since tiddlywiki might directly\n    // returned the auto-parsed field value (as in case of tags, or list)\n    // and this array would be read only!\n    list = (list || []).slice();\n\n    // transform\n    const toTRef = this.tracker.getTiddlerById(edge.to);\n\n    const index = list.indexOf(toTRef);\n    if (index > -1) {\n      list.splice(index, 1);\n    }\n\n    // save\n    utils.setField(tObj, type.name, $tw.utils.stringifyList(list));\n\n    return edge;\n\n  }\n}\n\n/*** Exports *******************************************************/\n\nexport { ListEdgeTypeSubscriber };\n"],"sourceRoot":"../../../../../../../src/plugins"}